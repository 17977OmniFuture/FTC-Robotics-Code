package org.firstinspires.ftc.teamcode.centerstage;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.hardware.motors.GoBILDA5202Series;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.Range;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.

@TeleOp(name="CSDriverTest", group="AA")
public class CSDriverTest extends LinearOpMode{

    //FL is the left front motor, FR is the right front motor, etc
    private DcMotor FL = null; //port 0
    private DcMotor FR = null; //port 1
    private DcMotor BR = null; //port 2
    private DcMotor BL = null; //port 3
    private DcMotor BigArm = null; //port 4

    private DcMotor leftEncoder = null;
    private DcMotor rightEncoder = null;
    private DcMotor headingEncoder = null;

    //constants which define the geometry of the robot and how this translates into movement
    final static double L = 23.02; //length between the two aligned encoders, in cm
    final static double B = 24.13; //length between the midpoint of aligned encoders and third encoder
    final static double R = 1.75; //wheel radius, in cm
    final static double N = 8192; //encoder ticks per revolution, REV encoder
    final static double cm_per_tick = 2 * Math.PI * R / N;

    //keeps track of the odometry values between updates
    public int currentLeftPos = 0;
    public int currentRightPos = 0;
    public int currentHeadPos = 0;
    private int oldLeftPos = 0;
    private int oldRightPos = 0;
    private int oldHeadPos = 0;
    private int relativeLeftPos = 0;
    private int relativeRightPos = 0;
    private int relativeHeadPos = 0;


    //note, in a mechanum drivetrain, you will frequently need to
    //make use of wheels that are ACROSS the robot from one another
    //e.g. FL and BR

    //In this section, between the ^^ definition of the motors and
    //the vv actual beginning of the OpMode (program that runs) is
    //where you put the functions you want to use in the code (ie)
    //claw function or drive function
    // target pos - vector3         start pos - vector3


    /*
    currentLeftPos, RightPos, HeadPos
    odometry(tXP, tYP, tHP) {

        //if too close to a wall get further away
        basically

        find the relative position of the target point
        tXP - cXP = rXP;
        tYP - cYP = rYP;
        CurAng = headingEncoder.getCurrentPosition();


        //I HAVE SIMPLIFIED THE FOLLOWING CODE, REMOVING THE 2PIR FROM THE FIRST AND SECOND EQUATIONS
        //IN THE FIRST EQUATION, IT IS IN THE NUMERATOR, IN THE SECOND IT IS IN THE DENOMINATOR
        //THIS MEANS IT SHOULD CANCEL OUT AND BE THE SAME. PLEASE
        //CurAng/N = number of revolutions. Times 2piR (the circumference of the odometry wheels) gives us linear distance
        CurAng = CurAng / N;
        //linear distance/circumference of the circle formed by the three encoders gives us number of robot rotations
        CurAng = CurAng/ L;
        //Turn the number of rotations into degrees
        CurAng = CurAng * 360;

        distance = Math.sqrt(rXP*rXP + rYP+rYP);
        if (rYP < 0) {

            TarAng = Math.acos(rXP/distance);
            TarAng = TarAng*180/Math.Pi();

        } else {

            TarAng = Math.acos(rXP/distance)-Math.Pi();
            TarAng = TarAng*180/Math.Pi();

        }

        //turning from degrees into relative to robot rotations
        //then turn from robot rotations into cm
        TarAng = TarAng/360;
        TarAng = TarAng * 72.26;
        //then cm into encoder wheel rotations
        //then rotations to number of ticks
        TarAng = TarAng/R;
        TarAng = TarAng*N;
        //^ this may be a negative number, while the motor will always track positive ones
        //thus i probably need to use absolute value and change directions on the wheel
        //like turn one way have things left, turn one way have things right ez

        //need to test if wheel read positive both ways?



        //circumference of circle of the encoders = 23pi cm = 72.26 cm




    }



     */


    /*public XyhVector START_POS = new XyhVector(213,102,Math.toRadians(-174));
    public XyhVector pos = new XyhVector(START_POS);

    public void odometry () {

        oldLeftPos = currentLeftPos;
        oldRightPos = currentRightPos;
        oldHeadPos = currentHeadPos;

        currentLeftPos = -leftEncoder.getCurrentPosition();
        currentRightPos = -rightEncoder.getCurrentPosition();
        currentHeadPos = headingEncoder.getCurrentPosition();

        int dn1 = currentLeftPos - oldLeftPos;
        int dn2 = currentRightPos - oldRightPos;
        int dn3 = currentHeadPos - oldHeadPos;

        double dtheta = cm_per_tick * (dn2-dn1) / L;
        double dx = cm_per_tick * (dn2+dn1) / 2;
        double dy = cm_per_tick * (dn3 - ((dn2-dn1)* B / L));

        double theta = pos.h + (dtheta/2);
        pos.x += (dx * Math.cos(theta)) - (dy * Math.sin(theta));
        pos.y += (dx * Math.cos(theta)) + (dy * Math.sin(theta));
        pos.h += dtheta;

    }*/

    @Override
    public void runOpMode() {


        FL = hardwareMap.get(DcMotor.class, "FL");
        FR = hardwareMap.get(DcMotor.class, "FR");
        BR = hardwareMap.get(DcMotor.class, "BR");
        BL = hardwareMap.get(DcMotor.class, "BL");
        BigArm = hardwareMap.get(DcMotor.class "BigArm");

        FL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        FR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        BR.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        BL.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        BigArm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        FL.setDirection(DcMotor.Direction.FORWARD);
        FR.setDirection(DcMotor.Direction.REVERSE);
        BR.setDirection(DcMotor.Direction.FORWARD);
        BL.setDirection(DcMotor.Direction.REVERSE);
        BigArm.setDirection(DcMotor.Direction.REVERSE);
        FL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        FR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        BL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        BR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        BigArm.setDirection(DcMotor.ZeroPowerBehavior.BRAKE);




        //set the odometry encoders to shadow the motors
        leftEncoder = FL;
        rightEncoder = BR;
        headingEncoder = FR;

        waitForStart();

        // run until the end of the match (driver presses STOP)
        while (opModeIsActive()) {

            // scale factor (maybe change values. Experimentation
            double scale_factor = 0.55;

            // base of motor power
            double motor_power_base = gamepad1.left_stick_y;

            // differentiating between ac and bd motors (strafing code)
            double a_BR_power_base = motor_power_base - gamepad1.left_stick_x;
            double b_BL_power_base = motor_power_base + gamepad1.left_stick_x;

            // setting the actual powers (turning code) - to make unable to turn right, remove the minuses
            double FL_power = a_BR_power_base - gamepad1.right_stick_x;
            double FR_power = b_BL_power_base + gamepad1.right_stick_x;
            double BR_power = a_BR_power_base + gamepad1.right_stick_x;
            double BL_power = b_BL_power_base - gamepad1.right_stick_x;

            // clip all the powers down to 1
            FL_power = Range.clip(FL_power * scale_factor, -1.0, 1.0);
            FR_power = Range.clip(FR_power * scale_factor, -1.0, 1.0);
            BR_power = Range.clip(BR_power * scale_factor, -1.0, 1.0);
            BL_power = Range.clip(BL_power * scale_factor, -1.0, 1.0);

            //arm
            if (gamepad1.a) {

                BigArm.setPower(1);

            } else if (gamepad1.x) {

                BigArm.setPower(-1);

            } else {

                BigArm.setPower(0);

            }

            // set the motor powers
            FL.setPower(FL_power);
            FR.setPower(FR_power);
            BR.setPower(BR_power);
            BL.setPower(BL_power);

            telemetry.addData("Motor 0 Odometry:", FR.getCurrentPosition());
            telemetry.addData("Motor 1 Odometry:", FL.getCurrentPosition());
            telemetry.addData("Motor 2 Odometry:", BR.getCurrentPosition());
            telemetry.update();




        }



    }



}
